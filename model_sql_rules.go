/*
SQLRules API - Evaluation of test coverage for SQL database queries

A set of services to evaluate the coverage of SQL database queries. Coverage criteria are implemented in a set of rules, that when evaluated with respect to a given database determine the coverage of the database with respect to the query.  Two kind of coverage rules are generated, Full Predicate Coverage rules for SQL (SQLFpc) and Mutants for SQL (SQLMutation)

API version: 3.3.19
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sqlrules

import (
	"encoding/json"
)

// checks if the SqlRules type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &SqlRules{}

// SqlRules Represents a set of sql coverage rules...
type SqlRules struct {
	// The class of the rules generated (`sqlfpc` or `sqlmutation`)
	RulesClass *string `json:"rulesClass,omitempty"`
	// The version number of the service that generates this rule
	Version *string `json:"version,omitempty"`
	// The environment of the service that generates this rule
	Environment *string `json:"environment,omitempty"`
	// A map of additional properties to store information about the execution of the rules against the database
	Summary *map[string]string `json:"summary,omitempty"`
	// The sql of the query that generates the rules
	Sql *string `json:"sql,omitempty"`
	// The sql after being parsed (only if specified by the `options` used when calling the service)
	Parsedsql *string `json:"parsedsql,omitempty"`
	// If empty, the service successfully obtained the rules, if not, indicates the error occurred, eg. the query is not syntactically correct. This field can be used to store runtime errors when executing the sql query
	Error *string `json:"error,omitempty"`
	// The set of rules generated
	Rules []SqlRule `json:"rules,omitempty"`
}

// NewSqlRules instantiates a new SqlRules object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSqlRules() *SqlRules {
	this := SqlRules{}
	return &this
}

// NewSqlRulesWithDefaults instantiates a new SqlRules object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSqlRulesWithDefaults() *SqlRules {
	this := SqlRules{}
	return &this
}

// GetRulesClass returns the RulesClass field value if set, zero value otherwise.
func (o *SqlRules) GetRulesClass() string {
	if o == nil || IsNil(o.RulesClass) {
		var ret string
		return ret
	}
	return *o.RulesClass
}

// GetRulesClassOk returns a tuple with the RulesClass field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SqlRules) GetRulesClassOk() (*string, bool) {
	if o == nil || IsNil(o.RulesClass) {
		return nil, false
	}
	return o.RulesClass, true
}

// HasRulesClass returns a boolean if a field has been set.
func (o *SqlRules) HasRulesClass() bool {
	if o != nil && !IsNil(o.RulesClass) {
		return true
	}

	return false
}

// SetRulesClass gets a reference to the given string and assigns it to the RulesClass field.
func (o *SqlRules) SetRulesClass(v string) {
	o.RulesClass = &v
}

// GetVersion returns the Version field value if set, zero value otherwise.
func (o *SqlRules) GetVersion() string {
	if o == nil || IsNil(o.Version) {
		var ret string
		return ret
	}
	return *o.Version
}

// GetVersionOk returns a tuple with the Version field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SqlRules) GetVersionOk() (*string, bool) {
	if o == nil || IsNil(o.Version) {
		return nil, false
	}
	return o.Version, true
}

// HasVersion returns a boolean if a field has been set.
func (o *SqlRules) HasVersion() bool {
	if o != nil && !IsNil(o.Version) {
		return true
	}

	return false
}

// SetVersion gets a reference to the given string and assigns it to the Version field.
func (o *SqlRules) SetVersion(v string) {
	o.Version = &v
}

// GetEnvironment returns the Environment field value if set, zero value otherwise.
func (o *SqlRules) GetEnvironment() string {
	if o == nil || IsNil(o.Environment) {
		var ret string
		return ret
	}
	return *o.Environment
}

// GetEnvironmentOk returns a tuple with the Environment field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SqlRules) GetEnvironmentOk() (*string, bool) {
	if o == nil || IsNil(o.Environment) {
		return nil, false
	}
	return o.Environment, true
}

// HasEnvironment returns a boolean if a field has been set.
func (o *SqlRules) HasEnvironment() bool {
	if o != nil && !IsNil(o.Environment) {
		return true
	}

	return false
}

// SetEnvironment gets a reference to the given string and assigns it to the Environment field.
func (o *SqlRules) SetEnvironment(v string) {
	o.Environment = &v
}

// GetSummary returns the Summary field value if set, zero value otherwise.
func (o *SqlRules) GetSummary() map[string]string {
	if o == nil || IsNil(o.Summary) {
		var ret map[string]string
		return ret
	}
	return *o.Summary
}

// GetSummaryOk returns a tuple with the Summary field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SqlRules) GetSummaryOk() (*map[string]string, bool) {
	if o == nil || IsNil(o.Summary) {
		return nil, false
	}
	return o.Summary, true
}

// HasSummary returns a boolean if a field has been set.
func (o *SqlRules) HasSummary() bool {
	if o != nil && !IsNil(o.Summary) {
		return true
	}

	return false
}

// SetSummary gets a reference to the given map[string]string and assigns it to the Summary field.
func (o *SqlRules) SetSummary(v map[string]string) {
	o.Summary = &v
}

// GetSql returns the Sql field value if set, zero value otherwise.
func (o *SqlRules) GetSql() string {
	if o == nil || IsNil(o.Sql) {
		var ret string
		return ret
	}
	return *o.Sql
}

// GetSqlOk returns a tuple with the Sql field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SqlRules) GetSqlOk() (*string, bool) {
	if o == nil || IsNil(o.Sql) {
		return nil, false
	}
	return o.Sql, true
}

// HasSql returns a boolean if a field has been set.
func (o *SqlRules) HasSql() bool {
	if o != nil && !IsNil(o.Sql) {
		return true
	}

	return false
}

// SetSql gets a reference to the given string and assigns it to the Sql field.
func (o *SqlRules) SetSql(v string) {
	o.Sql = &v
}

// GetParsedsql returns the Parsedsql field value if set, zero value otherwise.
func (o *SqlRules) GetParsedsql() string {
	if o == nil || IsNil(o.Parsedsql) {
		var ret string
		return ret
	}
	return *o.Parsedsql
}

// GetParsedsqlOk returns a tuple with the Parsedsql field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SqlRules) GetParsedsqlOk() (*string, bool) {
	if o == nil || IsNil(o.Parsedsql) {
		return nil, false
	}
	return o.Parsedsql, true
}

// HasParsedsql returns a boolean if a field has been set.
func (o *SqlRules) HasParsedsql() bool {
	if o != nil && !IsNil(o.Parsedsql) {
		return true
	}

	return false
}

// SetParsedsql gets a reference to the given string and assigns it to the Parsedsql field.
func (o *SqlRules) SetParsedsql(v string) {
	o.Parsedsql = &v
}

// GetError returns the Error field value if set, zero value otherwise.
func (o *SqlRules) GetError() string {
	if o == nil || IsNil(o.Error) {
		var ret string
		return ret
	}
	return *o.Error
}

// GetErrorOk returns a tuple with the Error field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SqlRules) GetErrorOk() (*string, bool) {
	if o == nil || IsNil(o.Error) {
		return nil, false
	}
	return o.Error, true
}

// HasError returns a boolean if a field has been set.
func (o *SqlRules) HasError() bool {
	if o != nil && !IsNil(o.Error) {
		return true
	}

	return false
}

// SetError gets a reference to the given string and assigns it to the Error field.
func (o *SqlRules) SetError(v string) {
	o.Error = &v
}

// GetRules returns the Rules field value if set, zero value otherwise.
func (o *SqlRules) GetRules() []SqlRule {
	if o == nil || IsNil(o.Rules) {
		var ret []SqlRule
		return ret
	}
	return o.Rules
}

// GetRulesOk returns a tuple with the Rules field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SqlRules) GetRulesOk() ([]SqlRule, bool) {
	if o == nil || IsNil(o.Rules) {
		return nil, false
	}
	return o.Rules, true
}

// HasRules returns a boolean if a field has been set.
func (o *SqlRules) HasRules() bool {
	if o != nil && !IsNil(o.Rules) {
		return true
	}

	return false
}

// SetRules gets a reference to the given []SqlRule and assigns it to the Rules field.
func (o *SqlRules) SetRules(v []SqlRule) {
	o.Rules = v
}

func (o SqlRules) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o SqlRules) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.RulesClass) {
		toSerialize["rulesClass"] = o.RulesClass
	}
	if !IsNil(o.Version) {
		toSerialize["version"] = o.Version
	}
	if !IsNil(o.Environment) {
		toSerialize["environment"] = o.Environment
	}
	if !IsNil(o.Summary) {
		toSerialize["summary"] = o.Summary
	}
	if !IsNil(o.Sql) {
		toSerialize["sql"] = o.Sql
	}
	if !IsNil(o.Parsedsql) {
		toSerialize["parsedsql"] = o.Parsedsql
	}
	if !IsNil(o.Error) {
		toSerialize["error"] = o.Error
	}
	if !IsNil(o.Rules) {
		toSerialize["rules"] = o.Rules
	}
	return toSerialize, nil
}

type NullableSqlRules struct {
	value *SqlRules
	isSet bool
}

func (v NullableSqlRules) Get() *SqlRules {
	return v.value
}

func (v *NullableSqlRules) Set(val *SqlRules) {
	v.value = val
	v.isSet = true
}

func (v NullableSqlRules) IsSet() bool {
	return v.isSet
}

func (v *NullableSqlRules) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSqlRules(val *SqlRules) *NullableSqlRules {
	return &NullableSqlRules{value: val, isSet: true}
}

func (v NullableSqlRules) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSqlRules) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


